.\" Automatically generated by Pod::Man 2.26 (Pod::Simple 3.23)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "WWW::Azantek 3"
.TH WWW::Azantek 3 "2012-08-28" "perl v5.8.8" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.IP "\(bu" 4
\&\fIget_ok()\fR
.IP "\(bu" 4
\&\fIpost_ok()\fR
.IP "\(bu" 4
\&\fIsubmit_form_ok()\fR
.IP "\(bu" 4
\&\fIfollow_link_ok()\fR
.IP "\(bu" 4
\&\fIclick_ok()\fR
.PP
This means you no longer have to do the following:
.PP
.Vb 3
\&    my $mech = Test::WWW::Mechanize\->new();
\&    $mech\->get_ok( $url, \*(AqFetch the intro page\*(Aq );
\&    $mech\->html_lint_ok( \*(AqIntro page looks OK\*(Aq );
.Ve
.PP
and can simply do
.PP
.Vb 2
\&    my $mech = Test::WWW::Mechanize\->new( autolint => 1 );
\&    $mech\->get_ok( $url, \*(AqFetch the intro page\*(Aq );
.Ve
.PP
The \f(CW\*(C`$mech\->get_ok()\*(C'\fR only counts as one test in the test count.  Both the
main \s-1IO\s0 operation and the linting must pass for the entire test to pass.
.PP
You can control autolint on the fly with the \f(CW\*(C`autolint\*(C'\fR method.
.SH "METHODS: HTTP VERBS"
.IX Header "METHODS: HTTP VERBS"
.ie n .SS "$mech\->get_ok($url, [ \e%LWP_options ,] $desc)"
.el .SS "\f(CW$mech\fP\->get_ok($url, [ \e%LWP_options ,] \f(CW$desc\fP)"
.IX Subsection "$mech->get_ok($url, [ %LWP_options ,] $desc)"
A wrapper around WWW::Mechanize's \fIget()\fR, with similar options, except
the second argument needs to be a hash reference, not a hash. Like
well-behaved \f(CW\*(C`*_ok()\*(C'\fR functions, it returns true if the test passed,
or false if not.
.PP
A default description of \*(L"\s-1GET\s0 \f(CW$url\fR\*(R" is used if none if provided.
.ie n .SS "$mech\->head_ok($url, [ \e%LWP_options ,] $desc)"
.el .SS "\f(CW$mech\fP\->head_ok($url, [ \e%LWP_options ,] \f(CW$desc\fP)"
.IX Subsection "$mech->head_ok($url, [ %LWP_options ,] $desc)"
A wrapper around WWW::Mechanize's \fIhead()\fR, with similar options, except
the second argument needs to be a hash reference, not a hash. Like
well-behaved \f(CW\*(C`*_ok()\*(C'\fR functions, it returns true if the test passed,
or false if not.
.PP
A default description of \*(L"\s-1HEAD\s0 \f(CW$url\fR\*(R" is used if none if provided.
.ie n .SS "$mech\->post_ok( $url, [ \e%LWP_options ,] $desc )"
.el .SS "\f(CW$mech\fP\->post_ok( \f(CW$url\fP, [ \e%LWP_options ,] \f(CW$desc\fP )"
.IX Subsection "$mech->post_ok( $url, [ %LWP_options ,] $desc )"
A wrapper around WWW::Mechanize's \fIpost()\fR, with similar options, except
the second argument needs to be a hash reference, not a hash. Like
well-behaved \f(CW\*(C`*_ok()\*(C'\fR functions, it returns true if the test passed,
or false if not.
.PP
A default description of \*(L"\s-1POST\s0 to \f(CW$url\fR\*(R" is used if none if provided.
.ie n .SS "$mech\->put_ok( $url, [ \e%LWP_options ,] $desc )"
.el .SS "\f(CW$mech\fP\->put_ok( \f(CW$url\fP, [ \e%LWP_options ,] \f(CW$desc\fP )"
.IX Subsection "$mech->put_ok( $url, [ %LWP_options ,] $desc )"
A wrapper around WWW::Mechanize's \fIput()\fR, with similar options, except
the second argument needs to be a hash reference, not a hash. Like
well-behaved \f(CW\*(C`*_ok()\*(C'\fR functions, it returns true if the test passed,
or false if not.
.PP
A default description of \*(L"\s-1PUT\s0 to \f(CW$url\fR\*(R" is used if none if provided.
.ie n .SS "$mech\->submit_form_ok( \e%parms [, $desc] )"
.el .SS "\f(CW$mech\fP\->submit_form_ok( \e%parms [, \f(CW$desc\fP] )"
.IX Subsection "$mech->submit_form_ok( %parms [, $desc] )"
Makes a \f(CW\*(C`submit_form()\*(C'\fR call and executes tests on the results.
The form must be found, and then submitted successfully.  Otherwise,
this test fails.
.PP
\&\fI\f(CI%parms\fI\fR is a hashref containing the parms to pass to \f(CW\*(C`submit_form()\*(C'\fR.
Note that the parms to \f(CW\*(C`submit_form()\*(C'\fR are a hash whereas the parms to
this function are a hashref.  You have to call this function like:
.PP
.Vb 7
\&    $mech\->submit_form_ok( {
\&            form_number => 3,
\&            fields      => {
\&                answer => 42
\&            },
\&        }, \*(Aqnow we just need the question\*(Aq
\&    );
.Ve
.PP
As with other test functions, \f(CW$desc\fR is optional.  If it is supplied
then it will display when running the test harness in verbose mode.
.PP
Returns true value if the specified link was found and followed
successfully.  The HTTP::Response object returned by \fIsubmit_form()\fR
is not available.
.ie n .SS "$mech\->follow_link_ok( \e%parms [, $desc] )"
.el .SS "\f(CW$mech\fP\->follow_link_ok( \e%parms [, \f(CW$desc\fP] )"
.IX Subsection "$mech->follow_link_ok( %parms [, $desc] )"
Makes a \f(CW\*(C`follow_link()\*(C'\fR call and executes tests on the results.
The link must be found, and then followed successfully.  Otherwise,
this test fails.
.PP
\&\fI\f(CI%parms\fI\fR is a hashref containing the parms to pass to \f(CW\*(C`follow_link()\*(C'\fR.
Note that the parms to \f(CW\*(C`follow_link()\*(C'\fR are a hash whereas the parms to
this function are a hashref.  You have to call this function like:
.PP
.Vb 1
\&    $mech\->follow_link_ok( {n=>3}, \*(Aqlooking for 3rd link\*(Aq );
.Ve
.PP
As with other test functions, \f(CW$desc\fR is optional.  If it is supplied
then it will display when running the test harness in verbose mode.
.PP
Returns a true value if the specified link was found and followed
successfully.  The HTTP::Response object returned by \fIfollow_link()\fR
is not available.
.ie n .SS "click_ok( $button[, $desc] )"
.el .SS "click_ok( \f(CW$button\fP[, \f(CW$desc\fP] )"
.IX Subsection "click_ok( $button[, $desc] )"
Clicks the button named by \f(CW$button\fR.  An optional \f(CW$desc\fR can
be given for the test.
.SH "METHODS: CONTENT CHECKING"
.IX Header "METHODS: CONTENT CHECKING"
.ie n .SS "$mech\->html_lint_ok( [$desc] )"
.el .SS "\f(CW$mech\fP\->html_lint_ok( [$desc] )"
.IX Subsection "$mech->html_lint_ok( [$desc] )"
Checks the validity of the \s-1HTML\s0 on the current page.  If the page is not
\&\s-1HTML\s0, then it fails.  The \s-1URI\s0 is automatically appended to the \fI\f(CI$desc\fI\fR.
.PP
Note that HTML::Lint must be installed for this to work.  Otherwise,
it will blow up.
.ie n .SS "$mech\->title_is( $str [, $desc ] )"
.el .SS "\f(CW$mech\fP\->title_is( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->title_is( $str [, $desc ] )"
Tells if the title of the page is the given string.
.PP
.Vb 1
\&    $mech\->title_is( \*(AqInvoice Summary\*(Aq );
.Ve
.ie n .SS "$mech\->title_like( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->title_like( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->title_like( $regex [, $desc ] )"
Tells if the title of the page matches the given regex.
.PP
.Vb 1
\&    $mech\->title_like( qr/Invoices for (.+)/
.Ve
.ie n .SS "$mech\->title_unlike( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->title_unlike( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->title_unlike( $regex [, $desc ] )"
Tells if the title of the page matches the given regex.
.PP
.Vb 1
\&    $mech\->title_unlike( qr/Invoices for (.+)/
.Ve
.ie n .SS "$mech\->base_is( $str [, $desc ] )"
.el .SS "\f(CW$mech\fP\->base_is( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->base_is( $str [, $desc ] )"
Tells if the base of the page is the given string.
.PP
.Vb 1
\&    $mech\->base_is( \*(Aqhttp://example.com/\*(Aq );
.Ve
.ie n .SS "$mech\->base_like( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->base_like( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->base_like( $regex [, $desc ] )"
Tells if the base of the page matches the given regex.
.PP
.Vb 1
\&    $mech\->base_like( qr{http://example.com/index.php?PHPSESSID=(.+)});
.Ve
.ie n .SS "$mech\->base_unlike( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->base_unlike( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->base_unlike( $regex [, $desc ] )"
Tells if the base of the page matches the given regex.
.PP
.Vb 1
\&    $mech\->base_unlike( qr{http://example.com/index.php?PHPSESSID=(.+)});
.Ve
.ie n .SS "$mech\->content_is( $str [, $desc ] )"
.el .SS "\f(CW$mech\fP\->content_is( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->content_is( $str [, $desc ] )"
Tells if the content of the page matches the given string
.ie n .SS "$mech\->content_contains( $str [, $desc ] )"
.el .SS "\f(CW$mech\fP\->content_contains( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->content_contains( $str [, $desc ] )"
Tells if the content of the page contains \fI\f(CI$str\fI\fR.
.ie n .SS "$mech\->content_lacks( $str [, $desc ] )"
.el .SS "\f(CW$mech\fP\->content_lacks( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->content_lacks( $str [, $desc ] )"
Tells if the content of the page lacks \fI\f(CI$str\fI\fR.
.ie n .SS "$mech\->content_like( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->content_like( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->content_like( $regex [, $desc ] )"
Tells if the content of the page matches \fI\f(CI$regex\fI\fR.
.ie n .SS "$mech\->content_unlike( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->content_unlike( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->content_unlike( $regex [, $desc ] )"
Tells if the content of the page does \s-1NOT\s0 match \fI\f(CI$regex\fI\fR.
.ie n .SS "$mech\->text_contains( $str [, $desc ] )"
.el .SS "\f(CW$mech\fP\->text_contains( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->text_contains( $str [, $desc ] )"
Tells if the text form of the page's content contains \fI\f(CI$str\fI\fR.
.PP
When your page contains \s-1HTML\s0 which is difficult, unimportant, or
unlikely to match over time as designers alter markup, use
\&\f(CW\*(C`text_contains\*(C'\fR instead of \*(L"content_contains\*(R".
.PP
.Vb 3
\& # <b>Hi, <i><a href="some/path">User</a></i>!</b>
\& $mech\->content_contains(\*(AqHi, User\*(Aq); # Fails.
\& $mech\->text_contains(\*(AqHi, User\*(Aq); # Passes.
.Ve
.PP
Text is determined by calling \f(CW\*(C`$mech\->text()\*(C'\fR.
See \*(L"content\*(R" in WWW::Mechanize.
.ie n .SS "$mech\->text_lacks( $str [, $desc ] )"
.el .SS "\f(CW$mech\fP\->text_lacks( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->text_lacks( $str [, $desc ] )"
Tells if the text of the page lacks \fI\f(CI$str\fI\fR.
.ie n .SS "$mech\->text_like( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->text_like( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->text_like( $regex [, $desc ] )"
Tells if the text form of the page's content matches \fI\f(CI$regex\fI\fR.
.ie n .SS "$mech\->text_unlike( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->text_unlike( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->text_unlike( $regex [, $desc ] )"
Tells if the text format of the page's content does \s-1NOT\s0 match \fI\f(CI$regex\fI\fR.
.ie n .SS "$mech\->has_tag( $tag, $text [, $desc ] )"
.el .SS "\f(CW$mech\fP\->has_tag( \f(CW$tag\fP, \f(CW$text\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->has_tag( $tag, $text [, $desc ] )"
Tells if the page has a \f(CW$tag\fR tag with the given content in its text.
.ie n .SS "$mech\->has_tag_like( $tag, $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->has_tag_like( \f(CW$tag\fP, \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->has_tag_like( $tag, $regex [, $desc ] )"
Tells if the page has a \f(CW$tag\fR tag with the given content in its text.
.ie n .SS "$mech\->\fIfollowable_links()\fP"
.el .SS "\f(CW$mech\fP\->\fIfollowable_links()\fP"
.IX Subsection "$mech->followable_links()"
Returns a list of links that Mech can follow.  This is only http and
https links.
.ie n .SS "$mech\->page_links_ok( [ $desc ] )"
.el .SS "\f(CW$mech\fP\->page_links_ok( [ \f(CW$desc\fP ] )"
.IX Subsection "$mech->page_links_ok( [ $desc ] )"
Follow all links on the current page and test for \s-1HTTP\s0 status 200
.PP
.Vb 1
\&    $mech\->page_links_ok(\*(AqCheck all links\*(Aq);
.Ve
.ie n .SS "$mech\->page_links_content_like( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->page_links_content_like( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->page_links_content_like( $regex [, $desc ] )"
Follow all links on the current page and test their contents for \fI\f(CI$regex\fI\fR.
.PP
.Vb 2
\&    $mech\->page_links_content_like( qr/foo/,
\&      \*(AqCheck all links contain "foo"\*(Aq );
.Ve
.ie n .SS "$mech\->page_links_content_unlike( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->page_links_content_unlike( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->page_links_content_unlike( $regex [, $desc ] )"
Follow all links on the current page and test their contents do not
contain the specified regex.
.PP
.Vb 2
\&    $mech\->page_links_content_unlike(qr/Restricted/,
\&      \*(AqCheck all links do not contain Restricted\*(Aq);
.Ve
.ie n .SS "$mech\->links_ok( $links [, $desc ] )"
.el .SS "\f(CW$mech\fP\->links_ok( \f(CW$links\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->links_ok( $links [, $desc ] )"
Follow specified links on the current page and test for \s-1HTTP\s0 status
200.  The links may be specified as a reference to an array containing
WWW::Mechanize::Link objects, an array of URLs, or a scalar \s-1URL\s0
name.
.PP
.Vb 2
\&    my @links = $mech\->find_all_links( url_regex => qr/cnn\e.com$/ );
\&    $mech\->links_ok( \e@links, \*(AqCheck all links for cnn.com\*(Aq );
\&
\&    my @links = qw( index.html search.html about.html );
\&    $mech\->links_ok( \e@links, \*(AqCheck main links\*(Aq );
\&
\&    $mech\->links_ok( \*(Aqindex.html\*(Aq, \*(AqCheck link to index\*(Aq );
.Ve
.ie n .SS "$mech\->link_status_is( $links, $status [, $desc ] )"
.el .SS "\f(CW$mech\fP\->link_status_is( \f(CW$links\fP, \f(CW$status\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->link_status_is( $links, $status [, $desc ] )"
Follow specified links on the current page and test for \s-1HTTP\s0 status
passed.  The links may be specified as a reference to an array
containing WWW::Mechanize::Link objects, an array of URLs, or a
scalar \s-1URL\s0 name.
.PP
.Vb 3
\&    my @links = $mech\->followable_links();
\&    $mech\->link_status_is( \e@links, 403,
\&      \*(AqCheck all links are restricted\*(Aq );
.Ve
.ie n .SS "$mech\->link_status_isnt( $links, $status [, $desc ] )"
.el .SS "\f(CW$mech\fP\->link_status_isnt( \f(CW$links\fP, \f(CW$status\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->link_status_isnt( $links, $status [, $desc ] )"
Follow specified links on the current page and test for \s-1HTTP\s0 status
passed.  The links may be specified as a reference to an array
containing WWW::Mechanize::Link objects, an array of URLs, or a
scalar \s-1URL\s0 name.
.PP
.Vb 3
\&    my @links = $mech\->followable_links();
\&    $mech\->link_status_isnt( \e@links, 404,
\&      \*(AqCheck all links are not 404\*(Aq );
.Ve
.ie n .SS "$mech\->link_content_like( $links, $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->link_content_like( \f(CW$links\fP, \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->link_content_like( $links, $regex [, $desc ] )"
Follow specified links on the current page and test the resulting
content of each against \fI\f(CI$regex\fI\fR.  The links may be specified as a
reference to an array containing WWW::Mechanize::Link objects, an
array of URLs, or a scalar \s-1URL\s0 name.
.PP
.Vb 3
\&    my @links = $mech\->followable_links();
\&    $mech\->link_content_like( \e@links, qr/Restricted/,
\&        \*(AqCheck all links are restricted\*(Aq );
.Ve
.ie n .SS "$mech\->link_content_unlike( $links, $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->link_content_unlike( \f(CW$links\fP, \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->link_content_unlike( $links, $regex [, $desc ] )"
Follow specified links on the current page and test that the resulting
content of each does not match \fI\f(CI$regex\fI\fR.  The links may be specified as a
reference to an array containing WWW::Mechanize::Link objects, an array
of URLs, or a scalar \s-1URL\s0 name.
.PP
.Vb 3
\&    my @links = $mech\->followable_links();
\&    $mech\->link_content_unlike( \e@links, qr/Restricted/,
\&      \*(AqNo restricted links\*(Aq );
.Ve
.ie n .SS "$mech\->stuff_inputs( [\e%options] )"
.el .SS "\f(CW$mech\fP\->stuff_inputs( [\e%options] )"
.IX Subsection "$mech->stuff_inputs( [%options] )"
Finds all free-text input fields (text, textarea, and password) in the
current form and fills them to their maximum length in hopes of finding
application code that can't handle it.  Fields with no maximum length
and all textarea fields are set to 66000 bytes, which will often be
enough to overflow the data's eventual recepticle.
.PP
There is no return value.
.PP
If there is no current form then nothing is done.
.PP
The hashref \f(CW$options\fR can contain the following keys:
.IP "\(bu" 4
ignore
.Sp
hash value is arrayref of field names to not touch, e.g.:
.Sp
.Vb 3
\&    $mech\->stuff_inputs( {
\&        ignore => [qw( specialfield1 specialfield2 )],
\&    } );
.Ve
.IP "\(bu" 4
fill
.Sp
hash value is default string to use when stuffing fields.  Copies
of the string are repeated up to the max length of each field.  E.g.:
.Sp
.Vb 3
\&    $mech\->stuff_inputs( {
\&        fill => \*(Aq@\*(Aq  # stuff all fields with something easy to recognize
\&    } );
.Ve
.IP "\(bu" 4
specs
.Sp
hash value is arrayref of hashrefs with which you can pass detailed
instructions about how to stuff a given field.  E.g.:
.Sp
.Vb 8
\&    $mech\->stuff_inputs( {
\&        specs=>{
\&            # Some fields are datatype\-constrained.  It\*(Aqs most common to
\&            # want the field stuffed with valid data.
\&            widget_quantity => { fill=>\*(Aq9\*(Aq },
\&            notes => { maxlength=>2000 },
\&        }
\&    } );
.Ve
.Sp
The specs allowed are \fIfill\fR (use this fill for the field rather than
the default) and \fImaxlength\fR (use this as the field's maxlength instead
of any maxlength specified in the \s-1HTML\s0).
.ie n .SS "$mech\->lacks_uncapped_inputs( [$comment] )"
.el .SS "\f(CW$mech\fP\->lacks_uncapped_inputs( [$comment] )"
.IX Subsection "$mech->lacks_uncapped_inputs( [$comment] )"
Executes a test to make sure that the current form content has no
text input fields that lack the \f(CW\*(C`maxlength\*(C'\fR attribute, and that each
\&\f(CW\*(C`maxlength\*(C'\fR value is a positive integer.  The test fails if the current
form has such a field, and succeeds otherwise.
.PP
Returns an array containing all text input fields in the current
form that do not specify a maximum input length.  Fields for which
the concept of input length is irrelevant, and controls that \s-1HTML\s0
does not allow to be capped (e.g. textarea) are ignored.
.PP
The inputs in the returned array are descended from HTML::Form::Input.
.PP
The return is true if the test succeeded, false otherwise.
.SH "METHODS: MISCELLANEOUS"
.IX Header "METHODS: MISCELLANEOUS"
.ie n .SS "$mech\->autolint( [$status] )"
.el .SS "\f(CW$mech\fP\->autolint( [$status] )"
.IX Subsection "$mech->autolint( [$status] )"
Without an argument, this method returns a true or false value indicating
whether autolint is active.
.PP
When passed an argument, autolint is turned on or off depending on whether
the argument is true or false, and the previous autolint status is returned.
As with the autolint option of \f(CW\*(C`new\*(C'\fR, \f(CW$status\fR can be an
HTML::Lint object.
.PP
If autolint is currently using an HTML::Lint object you provided,
the return is that object, so you can change and exactly restore
autolint status:
.PP
.Vb 3
\&    my $old_status = $mech\->autolint( 0 );
\&    ... operations that should not be linted ...
\&    $mech\->autolint( $old_status );
.Ve
.ie n .SS "$mech\->grep_inputs( \e%properties )"
.el .SS "\f(CW$mech\fP\->grep_inputs( \e%properties )"
.IX Subsection "$mech->grep_inputs( %properties )"
\&\fIgrep_inputs()\fR returns an array of all the input controls in the
current form whose properties match all of the regexes in \f(CW$properties\fR.
The controls returned are all descended from HTML::Form::Input.
.PP
If \f(CW$properties\fR is undef or empty then all inputs will be
returned.
.PP
If there is no current page, there is no form on the current
page, or there are no submit controls in the current form
then the return will be an empty array.
.PP
.Vb 7
\&    # get all text controls whose names begin with "customer"
\&    my @customer_text_inputs =
\&        $mech\->grep_inputs( {
\&            type => qr/^(text|textarea)$/,
\&            name => qr/^customer/
\&        }
\&    );
.Ve
.ie n .SS "$mech\->grep_submits( \e%properties )"
.el .SS "\f(CW$mech\fP\->grep_submits( \e%properties )"
.IX Subsection "$mech->grep_submits( %properties )"
\&\fIgrep_submits()\fR does the same thing as \fIgrep_inputs()\fR except that
it only returns controls that are submit controls, ignoring
other types of input controls like text and checkboxes.
.ie n .SS "$mech\->scrape_text_by_attr( $attr, $attr_value [, $html ] )"
.el .SS "\f(CW$mech\fP\->scrape_text_by_attr( \f(CW$attr\fP, \f(CW$attr_value\fP [, \f(CW$html\fP ] )"
.IX Subsection "$mech->scrape_text_by_attr( $attr, $attr_value [, $html ] )"
.ie n .SS "$mech\->scrape_text_by_attr( $attr, $attr_regex [, $html ] )"
.el .SS "\f(CW$mech\fP\->scrape_text_by_attr( \f(CW$attr\fP, \f(CW$attr_regex\fP [, \f(CW$html\fP ] )"
.IX Subsection "$mech->scrape_text_by_attr( $attr, $attr_regex [, $html ] )"
Returns an array of strings, each string the text surrounded by an
element with attribute \fI\f(CI$attr\fI\fR of value \fI\f(CI$value\fI\fR.  You can also pass in
a regular expression.  If nothing is found the return is an empty list.
In scalar context the return is the first string found.
.PP
If passed, \fI\f(CI$html\fI\fR is scraped instead of the current page's content.
.ie n .SS "scrape_text_by_id( $id [, $html ] )"
.el .SS "scrape_text_by_id( \f(CW$id\fP [, \f(CW$html\fP ] )"
.IX Subsection "scrape_text_by_id( $id [, $html ] )"
Finds all elements with the given id attribute and pulls out the text that that element encloses.
.PP
In list context, returns a list of all strings found. In scalar context, returns the first one found.
.PP
If \f(CW$html\fR is not provided then the current content is used.
.ie n .SS "$mech\->scraped_id_is( $id, $expected [, $msg] )"
.el .SS "\f(CW$mech\fP\->scraped_id_is( \f(CW$id\fP, \f(CW$expected\fP [, \f(CW$msg\fP] )"
.IX Subsection "$mech->scraped_id_is( $id, $expected [, $msg] )"
Scrapes the current page for given \s-1ID\s0 and tests that it matches the expected value.
.SH "NAME"
WWW::Azantek \- class to assist in interacting with Azantek user interface
.SH "VERSION"
.IX Header "VERSION"
This documentation describes version 0.01
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
The module lets the user interact with Azanteks useristrative web interface.
This can be used for automating tasks of processing data exports etc.
.PP
.Vb 1
\&    use WWW::Azantek;
\&
\&    #All mandatory parameters
\&    #Please note Azantek can be configured to use authorization on IP
\&    #meaning authentication is unnessesary
\&    my $wd = WWW::Azantek\->new({
\&        url => \*(Aqhttp://localhost/cgi\-bin/login.pl\*(Aq,
\&    });
\&
\&    #With optional authentication credentials
\&    my $wd = WWW::Azantek\->new({
\&        username => \*(Aqtester@tester.com\*(Aq,
\&        password => \*(Aqtester29\*(Aq,
\&        url => \*(Aqhttp://localhost/cgi\-bin/login.pl\*(Aq,
\&    });
\&
\&    #with verbosity enabled
\&    my $wd = WWW::Azantek\->new({
\&        username => \*(Aqtester@tester.com\*(Aq,
\&        password => \*(Aqtester29\*(Aq,
\&        url => \*(Aqhttp://localhost/cgi\-bin/login.pl\*(Aq,
\&        verbose  => 1,
\&    });
\&
\&    #With caching
\&    my $wd = WWW::Azantek\->new({
\&        cache    => 1,
\&        username => \*(Aqtester@tester.com\*(Aq,
\&        password => \*(Aqtester29\*(Aq,
\&        url => \*(Aqhttp://localhost/cgi\-bin/login.pl\*(Aq,
\&    });
\&
\&
\&    #With custom WWW::Mechanize object
\&    use WWW::Mechanize;
\&
\&    my $mech = WWW::Mechanize\->new(agent => \*(AqMEGAnice bot\*(Aq);
\&
\&    my $wd = WWW::Azantek\->new({
\&        username => \*(Aqtester@tester.com\*(Aq,
\&        password => \*(Aqtester29\*(Aq,
\&        url => \*(Aqhttp://localhost/cgi\-bin/login.pl\*(Aq,
\&        mech     => $mech,
\&    });
\&    
\&    
\&    #The intended use
\&    package My::WWW::Azantek::Subclass;
\&    
\&    sub processor {
\&        my ( $self, $content ) = @_;
\&        
\&        #Note the lines terminations are Windows CRLF
\&        my @lines = split /\er\en/, $$content;
\&        
\&        ...
\&        
\&        }
\&    }
\&    
\&    
\&    #Using your new class
\&    my $my = My::WWW::Azantek::Subclass\->new({
\&        username => \*(Aqtester@tester.com\*(Aq,
\&        password => \*(Aqtester29\*(Aq,
\&        url => \*(Aqhttp://localhost/cgi\-bin/login.pl\*(Aq,
\&    });
\&    
\&    my $content = $my\->retrieve();
\&    
\&    print $$content;
\&
\&
\&    #Using a processor implemented as a code reference
\&    $wd = WWW::Azantek\->new({
\&        username => \*(Aqtester@tester.com\*(Aq,
\&        password => \*(Aqtester29\*(Aq,
\&        url => \*(Aqhttp://localhost/cgi\-bin/login.pl\*(Aq,
\&        processor => sub {                
\&            ${$_[0]} =~ s/test/fest/;        
\&            return $_[0];
\&        },
\&    });    
\&
\&
\&    #Implementing a processor class
\&    my $processor = MY::Processor\->new();
\&    
\&    UNIVERSAL::can($processor, \*(Aqprocess\*(Aq);
\&    
\&    $wd = WWW::Azantek\->new({
\&        username => \*(Aqtester@tester.com\*(Aq,
\&        password => \*(Aqtester29\*(Aq,
\&        url => \*(Aqhttp://localhost/cgi\-bin/login.pl\*(Aq,
\&        processor => $processor,
\&    });
\&    
\&    my $content = $wd\->retrieve();
\&    
\&    print ${$content};
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is a simple wrapper around WWW::Mechanize it assists the user
in getting going with automating tasks related to the Azantek useristrative
web interface.
.PP
Such as:
.IP "\(bu" 4
manipulating data exports (removing, adjusting, calculating, adding
columns)
.IP "\(bu" 4
filling in missing data (combining data)
.IP "\(bu" 4
converting formats (from \s-1CSV\s0 to \s-1XML\s0, \s-1JSON\s0, \s-1CSV\s0, whatever)
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
This is the constructor.
.PP
The constructor takes a hash reference as input. The hash reference should
contain keys according to the following conventions:
.IP "\(bu" 4
username, optional username credential to access Azantek
.IP "\(bu" 4
password, optional password credential to access Azantek
.IP "\(bu" 4
url, the mandatory \s-1URL\s0 to retrieve data from (\*(L"retrieve\*(R")
.IP "\(bu" 4
mech, a WWW::Mechanize object if you have a pre instantiated object
or some other object implementing the the same \s-1API\s0 as WWW::Mechanize.
.Sp
The parameter is optional.
.Sp
See also cache parameter below for an example.
.IP "\(bu" 4
verbose, a flag for indicating verbosity, default is 0 (disabled), the
parameter is optional
.IP "\(bu" 4
cache, usage of a cache meaning that we internally use
WWW::Mechanize::Cached instead of WWW::Mechanize.
.Sp
The parameter is optional
.IP "\(bu" 4
processor
.Sp
This parameter can be used of you do not want to implement a subclass of
WWW::Azantek.
.Sp
The processor parameter can either be:
.RS 4
.IP "\(bu" 4
an object implementing a \*(L"proces\*(R" method, with the following profile:
.Sp
.Vb 1
\&    proces(\e$content);
.Ve
.IP "\(bu" 4
a code reference with the same profile, adhering to the following example:
.Sp
.Vb 1
\&    sub { return ${$_[0]} };
.Ve
.RE
.RS 4
.RE
.SS "retrieve"
.IX Subsection "retrieve"
Parameters:
.IP "\(bu" 4
a hash reference, the reference can be populated with statistic
information based on the lineprocessing (\*(L"processor\*(R") initiated from
\&\*(L"retrieve\*(R".
.PP
The method returns a scalar reference to a string containing the content
retrieved from the \s-1URL\s0 provided to the contructor (\*(L"new\*(R"). If the
\&\*(L"processor\*(R" method is overwritten you can manipulate the content prior
to being returned.
.SS "process"
.IX Subsection "process"
Takes the content retrieved (see: \*(L"retrieve\*(R") from the \s-1URL\s0 parameter provided
to the constructor (see: \*(L"new\*(R"). You can overwrite the behaviour via the
constructor (see: \*(L"new\*(R").
.PP
Parameters:
.IP "\(bu" 4
a scalar reference to a string to be processed line by line
.PP
The stub does however not do anything, but it returns the scalar reference
\&\fIuntouched\fR.
.SS "processor"
.IX Subsection "processor"
This is a wrapper for \*(L"process\*(R", provided for backwards compatibility.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.IP "\(bu" 4
Unable to authenticate, username and password not valid credentials
.IP "\(bu" 4
Both username and password is required for authentication
.Sp
If you want to use authentication you have to provide both \fBusername\fR and
\&\fBpassword\fR.
.IP "\(bu" 4
Unable to retrieve base \s-1URL:\s0 $@
.Sp
The base \s-1URL\s0 provided to retrieve gives an error.
.Sp
Please see: <http://search.cpan.org/perldoc?HTTP%3A%3AResponse> or
<http://search.cpan.org/~gaas/libwww\-perl/lib/HTTP/Status.pm>
.Sp
Test the \s-1URL\s0 in your browser to investigate.
.IP "\(bu" 4
Unable to retrieve \s-1URL:\s0 $@
.Sp
The base \s-1URL\s0 provided to retrieve gives an error.
.Sp
Please see: <http://search.cpan.org/perldoc?HTTP%3A%3AResponse> or
<http://search.cpan.org/~gaas/libwww\-perl/lib/HTTP/Status.pm>
.Sp
Test the \s-1URL\s0 in your browser to investigate.
.SH "CONFIGURATION AND ENVIRONMENT"
.IX Header "CONFIGURATION AND ENVIRONMENT"
The module requires Internet access to make sense and an account with Azantek
with username and password is required.
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
.IP "\(bu" 4
WWW::Mechanize
.IP "\(bu" 4
Carp
.SH "TEST AND QUALITY"
.IX Header "TEST AND QUALITY"
The tests are based on Test::MockObject::Extends and example data are
mocked dummy data. Please see the \s-1TODO\s0 section.
.PP
The test suite uses the following environment variables as flags:
.IP "\s-1TEST_AUTHOR\s0, to test prerequisites, using Test::Prereq" 4
.IX Item "TEST_AUTHOR, to test prerequisites, using Test::Prereq"
.PD 0
.IP "\s-1TEST_CRITIC\s0, to do a static analysis of the code, using Perl::Critic, see also \s-1QUALITY\s0 \s-1AND\s0 \s-1CODING\s0 \s-1STANDARD\s0" 4
.IX Item "TEST_CRITIC, to do a static analysis of the code, using Perl::Critic, see also QUALITY AND CODING STANDARD"
.PD
.SS "\s-1TEST\s0 \s-1COVERAGE\s0"
.IX Subsection "TEST COVERAGE"
The following data are based on an analysis created using Devel::Cover and
the distributions own test suite, instantiated the following way.
.PP
.Vb 1
\&    % ./Build testcover \-\-verbose
.Ve
.PP
\&\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\-
File                           stmt   bran   cond    sub    pod   time  total
\&\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\-
blib/lib/WWW/Azantek.pm     100.0  100.0  100.0  100.0  100.0  100.0  100.0
Total                         100.0  100.0  100.0  100.0  100.0  100.0  100.0
\&\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\-
.PP
Please note the report is based on version 0.03 of WWW::Azantek
.SH "QUALITY AND CODING STANDARD"
.IX Header "QUALITY AND CODING STANDARD"
The code passes Perl::Critic tests a severity: 1 (brutal)
.PP
The following policies have been disabled:
.IP "Perl::Critic::Policy::InputOutput::RequireBracedFileHandleWithPrint" 4
.IX Item "Perl::Critic::Policy::InputOutput::RequireBracedFileHandleWithPrint"
.PP
Perl::Critic resource file, can be located in the t/ directory of the
distribution \fIt/perlcriticrc\fR
.PP
Perl::Tidy resource file, can be obtained from the original author
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
No known bugs at this time.
.SH "BUG REPORTING"
.IX Header "BUG REPORTING"
Please report any bugs or feature requests via:
.IP "\(bu" 4
email: \f(CW\*(C`bug\-www\-dandomain at rt.cpan.org\*(C'\fR
.IP "\(bu" 4
\&\s-1HTTP:\s0 <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=WWW\-Azantek>
.SH "DEVELOPMENT"
.IX Header "DEVELOPMENT"
.IP "\(bu" 4
Subversion repository: <http://logicLAB.jira.com/svn/DAND>
.SH "TODO"
.IX Header "TODO"
.IP "\(bu" 4
Most of the work is done in the classes inheriting from this class,
there could however be work to do in the maintenance area, making this class
more informative if failing
.IP "\(bu" 4
I would like to add some integration test scripts so I can see that the
package works with real data apart from the mock.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
<http://www.dandomain.dk>
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc WWW::Azantek
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
Official Wiki
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.SH "AUTHOR"
.IX Header "AUTHOR"
.IP "\(bu" 4
pdam, \f(CW\*(C`<pdam.2010 at gmail.com>\*(C'\fR
.SH "MOTIVATION"
.IX Header "MOTIVATION"
This module grew out of a small script using WWW::Mechanize to fetch some
data from a website and changing it to satisfy the client utilizing the data.
.PP
More a more scripts where based on the original script giving a lot of redundant
code. Finally I refactored the lot to use some common code base.
.PP
After some time I refactored to an object oriented structure making it even
easier to maintain and adding more clients. This made the actual connectivity
into a package (this package) letting it loose as open source.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
.IP "\(bu" 4
Andy Lester (petdance) the author of WWW::Mechanize and
WWW::Mechanize:Cached, this module makes easy things easy and hard things
possible.
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright 2012 pdam, all rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 94:" 4
.IX Item "Around line 94:"
\&'=item' outside of any '=over'
.IP "Around line 2040:" 4
.IX Item "Around line 2040:"
You forgot a '=back' before '=head1'
